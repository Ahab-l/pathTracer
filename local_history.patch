Index: includes/Loader/Loader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/includes/Loader/Loader.h b/includes/Loader/Loader.h
--- a/includes/Loader/Loader.h	
+++ b/includes/Loader/Loader.h	(date 1710847887956)
@@ -37,187 +37,187 @@
         int primitiveId;
         int materialId;
     };
-public:
-    //https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html
-    static inline void LoadMeshes(std::vector<Triangle>&triangles,tinygltf::Model& model,std::map<int,std::vector<Primitive>>& meshPrimMap){
-        for(int gltfMeshIdx = 0;gltfMeshIdx<model.meshes.size();gltfMeshIdx++){
-            tinygltf::Mesh gltfMesh = model.meshes[gltfMeshIdx];
-            for(int gltfPrimIdx =0;gltfPrimIdx<gltfMesh.primitives.size();gltfPrimIdx++)
-            {
-                tinygltf::Primitive prim = gltfMesh.primitives[gltfPrimIdx];
+    public:
+        //https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html
+        static inline void LoadMeshes(std::vector<Triangle>&triangles,tinygltf::Model& model,std::map<int,std::vector<Primitive>>& meshPrimMap){
+            for(int gltfMeshIdx = 0;gltfMeshIdx<model.meshes.size();gltfMeshIdx++){
+                tinygltf::Mesh gltfMesh = model.meshes[gltfMeshIdx];
+                for(int gltfPrimIdx =0;gltfPrimIdx<gltfMesh.primitives.size();gltfPrimIdx++)
+                {
+                    tinygltf::Primitive prim = gltfMesh.primitives[gltfPrimIdx];
 
-                //Skip points and lines
-                if(prim.mode !=TINYGLTF_MODE_TRIANGLES)
-                    continue;
+                    //Skip points and lines
+                    if(prim.mode !=TINYGLTF_MODE_TRIANGLES)
+                        continue;
 
-                int indicesIndex  = prim.indices;
-                int positionIndex = -1;
-                int normalIndex   = -1;
-                int uv0Index      = -1;
+                    int indicesIndex  = prim.indices;
+                    int positionIndex = -1;
+                    int normalIndex   = -1;
+                    int uv0Index      = -1;
 
-                //检查primitive 是否带有这些属性如果没有，通过map.count()检查
-                if(prim.attributes.count("POSITION")>0)
-                {
-                    positionIndex = prim.attributes["POSITION"];
-                }
+                    //检查primitive 是否带有这些属性如果没有，通过map.count()检查
+                    if(prim.attributes.count("POSITION")>0)
+                    {
+                        positionIndex = prim.attributes["POSITION"];
+                    }
 
-                if (prim.attributes.count("NORMAL") > 0)
-                {
-                    normalIndex = prim.attributes["NORMAL"];
-                }
+                    if (prim.attributes.count("NORMAL") > 0)
+                    {
+                        normalIndex = prim.attributes["NORMAL"];
+                    }
 
-                if (prim.attributes.count("TEXCOORD_0") > 0)
-                {
-                    uv0Index = prim.attributes["TEXCOORD_0"];
-                }
+                    if (prim.attributes.count("TEXCOORD_0") > 0)
+                    {
+                        uv0Index = prim.attributes["TEXCOORD_0"];
+                    }
 
-                //Vertex positions
-                //通过层层索引找到buffer，access 能索引到一个buffer view，bufferview 可以索引到一个buffer，不过具体怎么读bufferview内offset是多少还是在accessor内
-                tinygltf::Accessor     positionAccessor = model.accessors[positionIndex];
-                tinygltf::BufferView positionBufferView = model.bufferViews[positionAccessor.bufferView];
-                const tinygltf::Buffer&  positionBuffer = model.buffers[positionBufferView.buffer];
-                const uint8_t*    positionBufferAddress = positionBuffer.data.data();
-                //Element size, in bytes, is (size in bytes of the 'componentType') * (number of components defined by 'type').
-                int                      positionStride = tinygltf::GetComponentSizeInBytes(positionAccessor.componentType)*tinygltf::GetNumComponentsInType(positionAccessor.type);
+                    //Vertex positions
+                    //通过层层索引找到buffer，access 能索引到一个buffer view，bufferview 可以索引到一个buffer，不过具体怎么读bufferview内offset是多少还是在accessor内
+                    tinygltf::Accessor     positionAccessor = model.accessors[positionIndex];
+                    tinygltf::BufferView positionBufferView = model.bufferViews[positionAccessor.bufferView];
+                    const tinygltf::Buffer&  positionBuffer = model.buffers[positionBufferView.buffer];
+                    const uint8_t*    positionBufferAddress = positionBuffer.data.data();
+                    //Element size, in bytes, is (size in bytes of the 'componentType') * (number of components defined by 'type').
+                    int                      positionStride = tinygltf::GetComponentSizeInBytes(positionAccessor.componentType)*tinygltf::GetNumComponentsInType(positionAccessor.type);
 
-                //Recheck
-                if(positionBufferView.byteStride>0)
-                    positionStride = positionBufferView.byteStride;
+                    //Recheck
+                    if(positionBufferView.byteStride>0)
+                        positionStride = positionBufferView.byteStride;
 
-                //FIXME: Some GLTF files like TriangleWithoutIndices gltf have no indices
-                //Vertex indice
-                tinygltf::Accessor     indexAccessor = model.accessors[indicesIndex];
-                tinygltf::BufferView indexBufferView = model.bufferViews[indexAccessor.bufferView];
-                const tinygltf::Buffer&  indexBuffer = model.buffers[indexBufferView.buffer];
-                const uint8_t*    indexBufferAddress = indexBuffer.data.data();
-                int                      indexStride = tinygltf::GetComponentSizeInBytes(indexAccessor.componentType) * tinygltf::GetNumComponentsInType(indexAccessor.type);
+                    //FIXME: Some GLTF files like TriangleWithoutIndices gltf have no indices
+                    //Vertex indice
+                    tinygltf::Accessor     indexAccessor = model.accessors[indicesIndex];
+                    tinygltf::BufferView indexBufferView = model.bufferViews[indexAccessor.bufferView];
+                    const tinygltf::Buffer&  indexBuffer = model.buffers[indexBufferView.buffer];
+                    const uint8_t*    indexBufferAddress = indexBuffer.data.data();
+                    int                      indexStride = tinygltf::GetComponentSizeInBytes(indexAccessor.componentType) * tinygltf::GetNumComponentsInType(indexAccessor.type);
 
-                //Normals
-                tinygltf::Accessor     normalAccessor;
-                tinygltf::BufferView normalBufferView;
-                const uint8_t * normalBufferAddress = nullptr;
-                int normalStride = -1;
-                if(normalIndex>-1){
-                    normalAccessor                       = model.accessors[normalIndex];
-                    normalBufferView                     = model.bufferViews[normalAccessor.bufferView];
-                    const tinygltf::Buffer& normalBuffer = model.buffers[normalBufferView.buffer];
-                    normalBufferAddress                  = normalBuffer.data.data();
-                    normalStride                         = tinygltf::GetComponentSizeInBytes(normalAccessor.componentType) * tinygltf::GetNumComponentsInType(normalAccessor.type);
-                    if(normalBufferView.byteStride>0)
-                        normalStride = normalBufferView.byteStride;
-                }
+                    //Normals
+                    tinygltf::Accessor     normalAccessor;
+                    tinygltf::BufferView normalBufferView;
+                    const uint8_t * normalBufferAddress = nullptr;
+                    int normalStride = -1;
+                    if(normalIndex>-1){
+                        normalAccessor                       = model.accessors[normalIndex];
+                        normalBufferView                     = model.bufferViews[normalAccessor.bufferView];
+                        const tinygltf::Buffer& normalBuffer = model.buffers[normalBufferView.buffer];
+                        normalBufferAddress                  = normalBuffer.data.data();
+                        normalStride                         = tinygltf::GetComponentSizeInBytes(normalAccessor.componentType) * tinygltf::GetNumComponentsInType(normalAccessor.type);
+                        if(normalBufferView.byteStride>0)
+                            normalStride = normalBufferView.byteStride;
+                    }
 
-                //Texture coordinates
-                tinygltf::Accessor     uv0Accessor;
-                tinygltf::BufferView uv0BufferView;
-                const uint8_t* uv0BufferAddress = nullptr;
-                int uv0Stride = -1;
-                if(uv0Index>-1){
-                    uv0Accessor                       = model.accessors[uv0Index];
-                    uv0BufferView                     = model.bufferViews[uv0Accessor.bufferView];
-                    const tinygltf::Buffer& uv0Buffer = model.buffers[uv0BufferView.buffer];
-                    uv0BufferAddress                  = uv0Buffer.data.data();
-                    uv0Stride                         = tinygltf::GetComponentSizeInBytes(uv0Accessor.componentType)*tinygltf::GetNumComponentsInType(uv0Accessor.type);
-                    if(uv0BufferView.byteStride>0)
-                        uv0Stride = uv0BufferView.byteStride;
-                }
+                    //Texture coordinates
+                    tinygltf::Accessor     uv0Accessor;
+                    tinygltf::BufferView uv0BufferView;
+                    const uint8_t* uv0BufferAddress = nullptr;
+                    int uv0Stride = -1;
+                    if(uv0Index>-1){
+                        uv0Accessor                       = model.accessors[uv0Index];
+                        uv0BufferView                     = model.bufferViews[uv0Accessor.bufferView];
+                        const tinygltf::Buffer& uv0Buffer = model.buffers[uv0BufferView.buffer];
+                        uv0BufferAddress                  = uv0Buffer.data.data();
+                        uv0Stride                         = tinygltf::GetComponentSizeInBytes(uv0Accessor.componentType)*tinygltf::GetNumComponentsInType(uv0Accessor.type);
+                        if(uv0BufferView.byteStride>0)
+                            uv0Stride = uv0BufferView.byteStride;
+                    }
 
-                std::vector<vec3> vertices;
-                std::vector<vec3> normals;
-                std::vector<vec2> uvs;
+                    std::vector<vec3> vertices;
+                    std::vector<vec3> normals;
+                    std::vector<vec2> uvs;
 
-                //get vertex data
+                    //get vertex data
 
-                for(size_t vertexIndex =0;vertexIndex<positionAccessor.count;vertexIndex++)
-                {
-                    vec3 vertex,normal;
-                    vec2 uv;
+                    for(size_t vertexIndex =0;vertexIndex<positionAccessor.count;vertexIndex++)
+                    {
+                        vec3 vertex,normal;
+                        vec2 uv;
 
-                    {
-                        const uint8_t* address = positionBufferAddress + positionBufferView.byteOffset + positionAccessor.byteOffset + (vertexIndex * positionStride);
-                        memcpy(&vertex, address, 12);
-                    }
+                        {
+                            const uint8_t* address = positionBufferAddress + positionBufferView.byteOffset + positionAccessor.byteOffset + (vertexIndex * positionStride);
+                            memcpy(&vertex, address, 12);
+                        }
 
-                    if (normalIndex > -1)
-                    {
-                        const uint8_t* address = normalBufferAddress + normalBufferView.byteOffset + normalAccessor.byteOffset + (vertexIndex * normalStride);
-                        memcpy(&normal, address, 12);
-                    }
+                        if (normalIndex > -1)
+                        {
+                            const uint8_t* address = normalBufferAddress + normalBufferView.byteOffset + normalAccessor.byteOffset + (vertexIndex * normalStride);
+                            memcpy(&normal, address, 12);
+                        }
 
-                    if (uv0Index > -1)
-                    {
-                        const uint8_t* address = uv0BufferAddress + uv0BufferView.byteOffset + uv0Accessor.byteOffset + (vertexIndex * uv0Stride);
-                        memcpy(&uv, address, 8);
-                    }
+                        if (uv0Index > -1)
+                        {
+                            const uint8_t* address = uv0BufferAddress + uv0BufferView.byteOffset + uv0Accessor.byteOffset + (vertexIndex * uv0Stride);
+                            memcpy(&uv, address, 8);
+                        }
 
-                    vertices.push_back(vertex);
-                    normals.push_back(normal);
-                    uvs.push_back(uv);
-                }
+                        vertices.push_back(vertex);
+                        normals.push_back(normal);
+                        uvs.push_back(uv);
+                    }
 
 
-                // Get index data
-                std::vector<int> indices(indexAccessor.count);
-                const uint8_t* baseAddress = indexBufferAddress + indexBufferView.byteOffset + indexAccessor.byteOffset;
-                if (indexStride == 1)
-                {
-                    std::vector<uint8_t> quarter;
-                    quarter.resize(indexAccessor.count);
+                    // Get index data
+                    std::vector<int> indices(indexAccessor.count);
+                    const uint8_t* baseAddress = indexBufferAddress + indexBufferView.byteOffset + indexAccessor.byteOffset;
+                    if (indexStride == 1)
+                    {
+                        std::vector<uint8_t> quarter;
+                        quarter.resize(indexAccessor.count);
 
-                    memcpy(quarter.data(), baseAddress, (indexAccessor.count * indexStride));
+                        memcpy(quarter.data(), baseAddress, (indexAccessor.count * indexStride));
 
-                    // Convert quarter precision indices to full precision
-                    for (size_t i = 0; i < indexAccessor.count; i++)
-                    {
-                        indices[i] = quarter[i];
-                    }
-                }
-                else if (indexStride == 2)
-                {
-                    std::vector<uint16_t> half;
-                    half.resize(indexAccessor.count);
+                        // Convert quarter precision indices to full precision
+                        for (size_t i = 0; i < indexAccessor.count; i++)
+                        {
+                            indices[i] = quarter[i];
+                        }
+                    }
+                    else if (indexStride == 2)
+                    {
+                        std::vector<uint16_t> half;
+                        half.resize(indexAccessor.count);
 
-                    memcpy(half.data(), baseAddress, (indexAccessor.count * indexStride));
+                        memcpy(half.data(), baseAddress, (indexAccessor.count * indexStride));
 
-                    // Convert half precision indices to full precision
-                    for (size_t i = 0; i < indexAccessor.count; i++)
-                    {
-                        indices[i] = half[i];
-                    }
-                }
-                else
-                {
-                    memcpy(indices.data(), baseAddress, (indexAccessor.count * indexStride));
-                }
+                        // Convert half precision indices to full precision
+                        for (size_t i = 0; i < indexAccessor.count; i++)
+                        {
+                            indices[i] = half[i];
+                        }
+                    }
+                    else
+                    {
+                        memcpy(indices.data(), baseAddress, (indexAccessor.count * indexStride));
+                    }
 
-                int offset = triangles.size();
-                triangles.resize(offset+indices.size()/3);
+                    int offset = triangles.size();
+                    triangles.resize(offset+indices.size()/3);
 
-                // Get triangles from vertex indices
-                for (int v = 0; v < indices.size(); v+=3)
-                {
-                    Triangle tri;
-                    Material m;
-                    m.metallic = 0.8f;
-                    m.roughness =0.4f;
-                    m.anisotropic =0.4f;
-                    m.baseColor = vec3(0.725, 0.71, 0.68);
+                    // Get triangles from vertex indices
+                    for (int v = 0; v < indices.size(); v+=3)
+                    {
+                        Triangle tri;
+                        Material m;
+                        m.metallic = 0.8f;
+                        m.roughness =0.4f;
+                        m.anisotropic =0.4f;
+                        m.baseColor = vec3(0.725, 0.71, 0.68);
 
-                    triangles[offset+v/3].p1 = vertices[indices[v]];
-                    triangles[offset+v/3].p2 = vertices[indices[v+1]];
-                    triangles[offset+v/3].p3 = vertices[indices[v+2]];
-                    triangles[offset+v/3].n1 = normals[indices[v]];
-                    triangles[offset+v/3].n2 = normals[indices[v+1]];
-                    triangles[offset+v/3].n3 = normals[indices[v+2]];
-                    triangles[offset+v/3].material = m;
+                        triangles[offset+v/3].p1 = vertices[indices[v]];
+                        triangles[offset+v/3].p2 = vertices[indices[v+1]];
+                        triangles[offset+v/3].p3 = vertices[indices[v+2]];
+                        triangles[offset+v/3].n1 = normals[indices[v]];
+                        triangles[offset+v/3].n2 = normals[indices[v+1]];
+                        triangles[offset+v/3].n3 = normals[indices[v+2]];
+                        triangles[offset+v/3].material = m;
 
-                }
+                    }
 
-            }
-            int x =1;
-        }
-        //Skip points and lines
-        return;
+                }
+                int x =1;
+            }
+            //Skip points and lines
+            return;
 
 
     }
